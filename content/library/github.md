---
title: "Github"
date: 2024-01-17T14:47:41Z
draft: true
---


# Github program
1. [actions](https://learn.microsoft.com/en-us/collections/n5p4a5z7keznp5)
2. [security](https://learn.microsoft.com/en-us/collections/rqymc6yw8q5rey)

## Intro
- [all metadata](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions)
- [triggers](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows)

## Blocks
- workflows
  - attached to a repository
  - contains jobs
  - triggered by events
- jobs
  - defines a runner
  - contains steps
  - run in parallel (default) or sequentially
  - runs on a separate machine
- steps
  - a single task (shell command or action)
  - in order

```yaml
name: CI
on:
  push:
    branches:
      - master # filter event
      - feature/* # feature/1
      - bugfix/** # bugfix/bug/1
    paths-ignore:
      - 'docs/**'
  pull_request:
    types:
      - opened # activity type
      - synchronize
      - reopened
    branches:
      - master
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '21'
      - name: Install dependencies
        run: npm install
      - name: Build
        run: npm run build
      - name: Test
        run: npm test
  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy
        run: echo "Deploying"
```

## Contexts
- secrets
- environment variables
- expressions
- functions
- contexts

```yaml
...
- name: Github context
  run: echo ${{ toJSON(github) }}
```
> [github.event](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows) is the event payload and is different for each event

## Commits
You can skip CI by adding `[skip ci]` to the commit message

## Job artifacts
Ouput (asset, logs etc.), generated by a job is called an artifact

```yaml
...
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - ...
      - Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            dist
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts # we'll have not a dist folder is the pwd, but it's content
```

## Job Outputs
You can pass data between jobs using outputs

```yaml
...
  build:
    runs-on: ubuntu-latest
    outputs:
      file-name: ${{ steps.id-name.outputs.step-file-name }}
    steps:
      - name: Set
        id: id-name
        run: find . -type f -name '*.txt' -exec echo "step-file-name={}' >> $GITHUB_OUTPUT ';'
#       Will not be supported so the above is a right way to do it
#       run: find . -type f -name '*.txt' -exec echo "::set-output step-file-name::{}' ';'
  deploy:
    needs: build                            # Needs to be defined in the same job
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
      - name: Deploy
        run: echo ${{ needs.build.outputs.build-number }}
```

## Dependency caching
Cache is the same acros jobs and workflows

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Cache dependencies      # Before the step that installs dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} # Acts as a cache key to validate the cache
          restore-keys: |
            ${{ runner.os }}-node-
      - name: Install dependencies
        run: npm install
      - name: Build
        run: npm run build
  deploy:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy
        run: echo "Deploying"
```

## Environment variables

```yaml
env:
  NODE_ENV: production # Global environment variable

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      DB_URL: ${{ secrets.DB_URL }} # Job specific environment variable
    steps:
      ...
      - name: Build
#       run: npm run build $NODE_ENV              # Accessing the environment variable
        run: | 
          npm run build ${{ env.NODE_ENV }}    # Accessing the environment variable
          echo ${{ secrets. DB_URL }}          # Accessing the secret; it needs to be set at the repository level or the organization level in the secrets action section
        env:
          STEP_ENV: ${{ secrets.DB_URL }}      # Step specific environment variable
```

## Environments
We can add environment specific secrets (like production, staging etc.)
The precedence of env is as follows:
- Environment level
- Repository level
- Organization level

We can specify the branch for the environment, so any other branches will not trigger the job

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    environment: production # Set the environment
    steps:
      ...
      - name: Build
        run: npm run build ${{ secrets.DB_URL }}
```

## Conditional Jobs & Steps
- jobs
  - if
  - needs
- steps
  - if
  - continue-on-error

By defualt, the next step will not run if the previous step fails
- fialure
- always
- cancelled
- success
howver, the overall job will be marked as failed, if not marked with `continue-on-error: true`

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      ...
      - name: Test
        id: test
        run: npm test
      - name: Post build
#       if: ${{ }} # Allows to omit in `if` condition
        if: steps.test.outcome == 'failure' && failure() # failure() is a function that returns true if the previous step failed; by default if the previous step fails, the next step will not run
        run: echo "Test failed"
  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: ${{ needs.build.result == 'success' }} # Job level condition
    steps:
    ...
  report:
    runs-on: ubuntu-latest
    needs: build
    if: failure() 
    steps:
    ...
```

```yaml
jobs:
  ...
    - name: Test
      id: test
      continue-on-error: true # Run a job even if Test fails and the overall job will be marked as success
      run: npm test

```

## Matrix
Run in parallel on different configurations

If 1 job fails the other will stoped and cancelled

```yaml

jobs:
  build:
    continue-on-error: true # Run a job if one of the matrixes fails
    strategy:
      matrix:
        node-version: [18, 21]
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      ...
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      ...
```

## Include & Exclude
```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 21]
        os: [ubuntu-latest, windows-latest] # total 2 * 2 = 4 jobs
    include: # adds a job, not a combination
      - job: build
        node-version: 19
        os: fedora-latest
    exclude:
      - os: windows-latest
        node-version: 18
    steps:
      ...
```

## Reusable workflows
```yaml
on: 
  workflow_call:
    inputs:
      artifact-name:
        required: true
        description: 'The name of the artifact to download'
        type: string
#       default: 'artifacts'

jobs:
  deploy:
    ...
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact-name }}
      ...

# in another workflow

jobs:
  build:
    ...
    - Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: dist
  deploy:
    needs: build
    uses: ./.github/workflow/<file with workflow from root>.yml
    with:
      artifact-name: build-artifacts
  
```
